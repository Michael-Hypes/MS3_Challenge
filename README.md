# MS3 CSV Coding Challenge

# Summary of Purpose
The Purpose of this Code is to dynamically take in a 10 column CSV file and parse its tuples based on the criteria of the tuples within the CSV. If any tuple is found to not meet the 10 field criteria, then it will be rejected and placed into a file to store them and their data. Should they pass, the tuples will be inserted into an SQlite databse for storage. This project will also create a .log file to show the total number of processed tuples and the number of passed/failed tuples. All created Files (.log, -bad.csv) will be in the MS3_CSV_Challenge Folder.
    
# How to Use
I was planning to make it a CLI ran code but I was afraid there may be some complications so I simply made it to where you could load the folder/.java files in any Java IDE to compile it from the MS3_CSV_Challenge.java class, it should work (It did on my PC). If you want to change the file being read then you simply just make sure the file is in the MS3_CSV_Challenge folder with the other CSV file and change the fname string variable in the main method (marked with a comment that you may need to change it) to the file name without the .csv extension. If needed, the .jar drivers are in the Drivers folder in the MS3_CSV_Challenge Folder.

# Overview of Approach, Design Choices, and Assumptions 
My approach to solving this problem was to create an SqliteHandler class to control the connection and functionality of the database. In the main class (MS3_CSV_Challenge.java) I took in the file name and used that to create the names of the other required files. Using the original file, I chose to pass it into a scanner variable and loop through the variable until I was at the end. While I was on each individual line of the CSV file I split the data on the comma with a reggex to insure I didn’t split the photo data if it contained any ","s. After this was done I iterated through the array to check for empty positions or if there was even enough, if the line met the criteria I would call to the SqliteHandler class to insert it into the database, if not, I wrote it to the -bad text file. Lastly I would write to the log file the number of tuples read, gathered via the variables incremented in the if(valid) and if(!valid) condition checks. 

I designed it to be as efficient as I thought possible and can’t really think of any particular assumptions I had made. I thought the directions were pretty straightforward.
